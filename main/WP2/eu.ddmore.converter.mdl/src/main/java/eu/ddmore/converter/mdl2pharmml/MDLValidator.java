/*
 * generated by Xtext
 */
package eu.ddmore.converter.mdl2pharmml;

import java.util.List;

import org.apache.log4j.Logger;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.Resource.Diagnostic;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.google.inject.Inject;

import eu.ddmore.convertertoolbox.api.response.ConversionDetail;
import eu.ddmore.convertertoolbox.api.response.ConversionDetail.Severity;
import eu.ddmore.convertertoolbox.api.response.ConversionReport;
import eu.ddmore.convertertoolbox.api.response.ConversionReport.ConversionCode;
import eu.ddmore.convertertoolbox.domain.ConversionDetailImpl;
import eu.ddmore.mdl.validation.UnsupportedFeaturesValidator;

/**
 * Validates an MDL file, checking both syntax and semantics.
 * Errors and warnings are written to a {@link ConversionReport}.
 */
public class MDLValidator {

    private final static Logger LOG = Logger.getLogger(MDLValidator.class);
	
    @Inject
    private IResourceValidator validator;
	
	/**
	 * Perform the syntax checking and the semantics checking.
	 * <p>
	 * @param resource - as created by {@link org.eclipse.xtext.resource.XtextResourceSet.getResource(URI, boolean)}, representing the MDL file content
	 * @param report - {@link ConversionReport} to which errors and warnings will be written
	 * @return true if validation passed with no errors and zero or more warnings; false if any errors were encountered
	 */
	protected boolean validate(final Resource resource, final ConversionReport report) {
        
        // Syntactic validation of the MDL resource
        EList<Diagnostic> syntaxErrors = resource.getErrors();
        EList<Diagnostic> syntaxWarnings = resource.getWarnings();
        if (!syntaxWarnings.isEmpty()) {
            LOG.warn(String.format("%1$d syntax warning(s) encountered in parsing MDL file %2$s", syntaxWarnings.size(), resource.getURI()));
            for (Diagnostic w : syntaxWarnings) {
                LOG.warn(w);
                final ConversionDetail detail = new ConversionDetailImpl();
                detail.setMessage(w.toString());
                detail.setSeverity(Severity.WARNING);
                report.addDetail(detail);
            }
        }
        if (!syntaxErrors.isEmpty()) {
            LOG.error(String.format("%1$d syntax error(s) encountered in parsing MDL file %2$s", syntaxErrors.size(), resource.getURI()));
            for (Diagnostic e : syntaxErrors) {
                LOG.error(e);
                final ConversionDetail detail = new ConversionDetailImpl();
                detail.setMessage(e.toString());
                detail.setSeverity(Severity.ERROR);
                report.addDetail(detail);
            }
            report.setReturnCode(ConversionCode.FAILURE);
            return false; // Bail out
        }
        
        // Semantic validation of the MDL resource
        List<Issue> issues = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
        if (!issues.isEmpty()) {
            LOG.warn(String.format("%1$d semantic error(s) and/or warning(s) encountered in parsing MDL file %2$s", issues.size(), resource.getURI()));
            boolean semanticErrors = false;
            for (Issue issue : issues) {
                switch (issue.getSeverity()) {
                    case ERROR: {
                        semanticErrors = true;
                        LOG.error(issue);
                        final ConversionDetail detail = new ConversionDetailImpl();
                        detail.setMessage(issue.getMessage());
                        detail.setSeverity(Severity.ERROR);
                        report.addDetail(detail);
                        break;
                    }
                    case WARNING: {
                        LOG.warn(issue);
                        Severity severity = Severity.WARNING;
                        if (issue.getCode().equals(UnsupportedFeaturesValidator.FEATURE_NOT_SUPPORTED)) {
                            // Promote 'unsupported feature' warnings to errors
                            severity = Severity.ERROR;
                            semanticErrors = true;
                        }
                        final ConversionDetail detail = new ConversionDetailImpl();
                        detail.setMessage(issue.getMessage());
                        detail.setSeverity(severity);
                        report.addDetail(detail);
                        break;
                    }
                    case INFO:
                    case IGNORE:
                }
            }
            if (semanticErrors) {
                report.setReturnCode(ConversionCode.FAILURE);
                return false; // Bail out
            }
        }

        return true; // Successfully passed syntax validation and semantic validation
	}
}
