# nt2mdl 1.046 beta Nick Holford n.holford@auckland.ac.nz
Hamren_dat = dataobj{
### Data object
# The data object specifies a table of columns of data variables and the variable names which will be also used by the model object
   DATA_INPUT_VARIABLES{
      ID=list(type=categorical)
      TIME=list(type=continuous,units="h")
      DV=list(type=continuous)
      DOSE=list(type=continuous)
      CL=list(type=continuous)
      V=list(type=continuous)
      SEX=list(type=categorical)#,define=list(female=0,male=1,MISSING=-99),recode=list("F","M","UNK"))
      TREAT=list(type=continuous)
      ORIG=list(type=continuous)
   }# end DATA_INPUT_VARIABLES

   SOURCE{
      myData=list(
           file="hamren2008_data.csv",
           inputformat=nonmemFormat,
           ignore="#")
   }# end SOURCE
} # end data object

Hamren_par = parobj{
### Parameter object
# The parameter object defines the numerical values of the parameters with optional constraints (lo and high values) and units.

   STRUCTURAL{
# The STRUCTURAL block define the structural model parameters.
      #THETA
      POP_FPG_BASELINE_Y=list(value=8.2)
      POP_FPG_BASELINE_N=list(value=8.72)
      POP_K_OUT_FPG=list(value=0.0367)
      POP_E_MAX_FPG=list(value=0.698)
      POP_EC_50_FPG_M=list(value=1.48)
      POP_EC_50_FPG_F=list(value=0.88)
      POP_FPG_WASHOUT_Y=list(value=0.164)
      POP_FPG_WASHOUT_N=list(value=0 ,fix=true)
      POP_RES_FPG=list(value=0.0964)
      POP_GAMMA=list(value=0.743)
      POP_K_GLUCOSE=list(value=0.000181)
      POP_RBC_LIFESPAN=list(value=135)
      POP_K_IN_RBC_M=list(value=1.11)
      POP_K_IN_RBC_F=list(value=1.02)
      POP_E_MAX_DILUTION=list(value=0.682)
      POP_EC_50_DILUTION=list(value=8.25)
      POP_K_OUT_DILUTION=list(value=0.0305)
      POP_RES_HBA1C=list(value=0.0495)
      POP_RES_HB=list(value=0.0298)
   }# end STRUCTURAL

   VARIABILITY{
# The VARIABILITY block has a more complex structure because it needs to express a lower triangular matrix of parameters and how they are related to each other.
# VARIABILITY parameters may be expressed with a type of "SD" which implies standard deviations on the diagonal and correlations
# on the lower off diagonal elements or "VAR" which implies variances and covariances.
      #OMEGA
      PPV_FPG_BASELINE=list(value=0 ,type=VAR,fix=true)
      PPV_EC50_FPG=list(value=0 ,type=VAR,fix=true)
      PPV_FPG_WASHOUT=list(value=0 ,type=VAR,fix=true)
      PPV_RES_FPG=list(value=0 ,type=VAR,fix=true)
      PPV_FPG_GAMMA=list(value=0 ,type=VAR,fix=true)
      PPV_K_IN_RBC=list(value=0 ,type=VAR,fix=true)
      PPV_EC_50_DILUTION=list(value=0 ,type=VAR,fix=true)
      PPV_RES_HBA1C=list(value=0 ,type=VAR,fix=true)
      PPV_RES_HB=list(value=0 ,type=VAR,fix=true)
      #SIGMA
      RUV_EPS_FPG=list(value=1 ,type=VAR,fix=true)
      RUV_EPS_HBA1C=list(value=1 ,type=VAR,fix=true)
      RUV_EPS_HB=list(value=1 ,type=VAR,fix=true)

   }# end VARIABILITY

} # end of parameter object

Hamren_mdl = mdlobj{
### Model object
# The model object receives a list of input data variables from the data object and parameters (constants)from the parameter object.
# The parameter and variable names in the model object must be matched by a similar name in the parameter and data objects.
# Note that variables in the data object and parameters may be defined in the parameter object that are not referenced in the model object.
# Model variables are derived from the input data variables and parameters using algebraic expressions.

   MODEL_INPUT_VARIABLES{
# A name for each input data variable is required. Special uses of input data variables are indicated by the use attribute if the data variable name is not a standard name. Standard names may include ID, IDV, AMT, DV, MDV, etc. similar to standard data items recognized by NM-TRAN or Monolix. The type option is not required but may be useful as metadata. This kind of metadata (with an option to recode) could alternatively be specified in the data object.
      ID=list(use=id,level=2)
      TIME=list(use=idv,units="h")
      DV=list(type=continuous,use=dv,level=1)
      DOSE=list(type=continuous,use=covariate)
      CL=list(type=continuous,use=covariate)
      V=list(type=continuous,use=covariate)
      SEX=list(type=categorical)#,define=list(female=0,male=1,MISSING=-99),use=covariate)
      TREAT=list(type=continuous,use=covariate)
      ORIG=list(type=continuous,use=covariate)
   }# end MODEL_INPUT_VARIABLES

# The STRUCTURAL_PARAMETERS Block defines the structural model parameters.
   STRUCTURAL_PARAMETERS{
# A name for each parameter is required. Other attributes such as units are optional.
# Units may be used to achieve consistency between the parameter, data and model object values.
# This could be implemented during the WP2 translation process.

      #THETA
      POP_FPG_BASELINE_Y
      POP_FPG_BASELINE_N
      POP_K_OUT_FPG
      POP_E_MAX_FPG
      POP_EC_50_FPG_M
      POP_EC_50_FPG_F
      POP_FPG_WASHOUT_Y
      POP_FPG_WASHOUT_N
      POP_RES_FPG
      POP_GAMMA
      POP_K_GLUCOSE
      POP_RBC_LIFESPAN
      POP_K_IN_RBC_M
      POP_K_IN_RBC_F
      POP_E_MAX_DILUTION
      POP_EC_50_DILUTION
      POP_K_OUT_DILUTION
      POP_RES_HBA1C
      POP_RES_HB
   }# end STRUCTURAL_PARAMETERS

   VARIABILITY_PARAMETERS{
# The VARIABILITY_PARAMETERS Block defines the variability parameters.
      #OMEGA
      PPV_FPG_BASELINE
      PPV_EC50_FPG
      PPV_FPG_WASHOUT
      PPV_RES_FPG
      PPV_FPG_GAMMA
      PPV_K_IN_RBC
      PPV_EC_50_DILUTION
      PPV_RES_HBA1C
      PPV_RES_HB
      #SIGMA
      RUV_EPS_FPG
      RUV_EPS_HBA1C
      RUV_EPS_HB
   }# end VARIABILITY_PARAMETERS

   GROUP_VARIABLES{
# The GROUP_VARIABLES block is used to express covariate models i.e. the fixed effect differences in parameters predictable from data variables.
# If there are no covariate effects to model then this block is not required.
# NONMEM may be able to take advantage of knowing that variables defined in this block represent the central tendency
# of the distribution of random effects defined in the INDIVIDUAL_VARIABLES block (known as MU referencing).
# In this example the prefix "grp_" for a variable name could be a hint that this is a MU variable for NM-TRAN.
# Other model variables may be defined in this block according to user preference.

   
   if (SEX==0) {
      POP_EC_50_FPG = POP_EC_50_FPG_F
      POP_K_IN_RBC = POP_K_IN_RBC_F
   } else {
      POP_EC_50_FPG = POP_EC_50_FPG_M
      POP_K_IN_RBC = POP_K_IN_RBC_M
   }
   if (TREAT==0) {
      POP_FPG_BASELINE = POP_FPG_BASELINE_N
      POP_FPG_WASHOUT = POP_FPG_WASHOUT_N
   } else {
      POP_FPG_BASELINE = POP_FPG_BASELINE_Y
      POP_FPG_WASHOUT = POP_FPG_WASHOUT_Y
   }
   }# end GROUP_VARIABLES


   RANDOM_VARIABLE_DEFINITION{
# The RANDOM_VARIABLE_DEFINITION block is used to define the distribution of random variables.
      eta_PPV_FPG_BASELINE ~ (type=normal, mean=0, var=PPV_FPG_BASELINE,level=ID)
      eta_PPV_EC50_FPG ~ (type=normal, mean=0, var=PPV_EC50_FPG,level=ID)
      eta_PPV_FPG_WASHOUT ~ (type=normal, mean=0, var=PPV_FPG_WASHOUT,level=ID)
      eta_PPV_RES_FPG ~ (type=normal, mean=0, var=PPV_RES_FPG,level=ID)
      eta_PPV_FPG_GAMMA ~ (type=normal, mean=0, var=PPV_FPG_GAMMA,level=ID)
      eta_PPV_K_IN_RBC ~ (type=normal, mean=0, var=PPV_K_IN_RBC,level=ID)
      eta_PPV_EC_50_DILUTION ~ (type=normal, mean=0, var=PPV_EC_50_DILUTION,level=ID)
      eta_PPV_RES_HBA1C ~ (type=normal, mean=0, var=PPV_RES_HBA1C,level=ID)
      eta_PPV_RES_HB ~ (type=normal, mean=0, var=PPV_RES_HB,level=ID)
      eps_RUV_EPS_FPG ~ (type=normal, mean=0, var=RUV_EPS_FPG,level=DV)
      eps_RUV_EPS_HBA1C ~ (type=normal, mean=0, var=RUV_EPS_HBA1C,level=DV)
      eps_RUV_EPS_HB ~ (type=normal, mean=0, var=RUV_EPS_HB,level=DV)
   }# end RANDOM_VARIABLE_DEFINITION

   INDIVIDUAL_VARIABLES{
# The INDIVIDUAL_VARIABLES block is used to express the individual variables and their distribution.
# If this is not a population model then this block is not required.

   FPG_BASELINE = POP_FPG_BASELINE*exp(eta_PPV_FPG_BASELINE) 
   EC_50_FPG = POP_EC_50_FPG*exp(eta_PPV_EC50_FPG) 
   FPG_WASHOUT = POP_FPG_WASHOUT*exp(eta_PPV_FPG_WASHOUT) 
   RES_FPG = POP_RES_FPG*exp(eta_PPV_RES_FPG) 
   GAMMA = POP_GAMMA*exp(eta_PPV_FPG_GAMMA) 
   K_IN_RBC = POP_K_IN_RBC*exp(eta_PPV_K_IN_RBC) 
   EC_50_DILUTION = POP_EC_50_DILUTION*exp(eta_PPV_EC_50_DILUTION) 
   RES_HBA1C = POP_RES_HBA1C*exp(eta_PPV_RES_HBA1C) 
   RES_HB = POP_RES_HB*exp(eta_PPV_RES_HB)
   #initial conditions
   K_IN_FPG = POP_K_OUT_FPG*FPG_BASELINE
   K_TR = 4/POP_RBC_LIFESPAN
   FPG_0 = FPG_BASELINE
   NON_RBC1_0 = K_IN_RBC/(K_TR+POP_K_GLUCOSE*FPG_BASELINE^ GAMMA)
   NON_RBC2_0 = K_TR*NON_RBC1_0/(K_TR+POP_K_GLUCOSE*FPG_0^ GAMMA)
   NON_RBC3_0 = K_TR*NON_RBC2_0/(K_TR+POP_K_GLUCOSE*FPG_0^ GAMMA)
   NON_RBC4_0 = K_TR*NON_RBC3_0/(K_TR+POP_K_GLUCOSE*FPG_0^ GAMMA)
   RBC1_0 = POP_K_GLUCOSE*(FPG_0^ GAMMA)*NON_RBC1_0/K_TR
   RBC2_0 = (POP_K_GLUCOSE*(FPG_0^ GAMMA)*NON_RBC2_0+K_TR*RBC1_0)/K_TR
   RBC3_0 = (POP_K_GLUCOSE*(FPG_0^ GAMMA)*NON_RBC3_0+K_TR*RBC2_0)/K_TR
   RBC4_0 = (POP_K_GLUCOSE*(FPG_0^ GAMMA)*NON_RBC4_0+K_TR*RBC3_0)/K_TR
   VHB_0 = 1
   KOUT = CL/V

   }# end INDIVIDUAL_VARIABLES

   MODEL_PREDICTION{
# The MODEL_PREDICTION block calculates model predictions based on model variables defined in the previous model object blocks.
# Code in this block expresses the structural model after group and individual parameter differences have been included.
# It can be considered as an expression of a deterministic prediction. It is the essential component of a shared sub-model.
# This block should not contain any covariate computations expressing predictable or unpredictable (random) between subject differences.


      ## COMPARTMENTS
      ## 
      ## COMP =  QP
      ## COMP =  FPG
      ## COMP =  NON_RBC1
      ## COMP =  NON_RBC2
      ## COMP =  NON_RBC3
      ## COMP =  NON_RBC4
      ## COMP =  RBC1
      ## COMP =  RBC2
      ## COMP =  RBC3
      ## COMP =  RBC4
      ## COMP =  VHB

   ODE{
   CP = QP/V
      QP=ode(deriv= -KOUT*QP,init= 0)
      FPG=ode(deriv= K_IN_FPG*(1+FPG_WASHOUT)-POP_K_OUT_FPG*FPG*(1+POP_E_MAX_FPG*CP/(EC_50_FPG+CP)),init= FPG_0)
      NON_RBC1=ode(deriv= K_IN_RBC-(K_TR+POP_K_GLUCOSE*FPG^ GAMMA)*NON_RBC1,init= NON_RBC1_0)
      NON_RBC2=ode(deriv= K_TR*NON_RBC1-(K_TR+POP_K_GLUCOSE*FPG^ GAMMA)*NON_RBC2,init= NON_RBC2_0)
      NON_RBC3=ode(deriv= K_TR*NON_RBC2-(K_TR+POP_K_GLUCOSE*FPG^ GAMMA)*NON_RBC3,init= NON_RBC3_0)
      NON_RBC4=ode(deriv= K_TR*NON_RBC3-(K_TR+POP_K_GLUCOSE*FPG^ GAMMA)*NON_RBC4,init= NON_RBC4_0)
      RBC1=ode(deriv= POP_K_GLUCOSE*(FPG^ GAMMA)*NON_RBC1-K_TR*RBC1,init= RBC1_0)
      RBC2=ode(deriv= POP_K_GLUCOSE*(FPG^ GAMMA)*NON_RBC2+K_TR*RBC1-K_TR*RBC2,init= RBC2_0)
      RBC3=ode(deriv= POP_K_GLUCOSE*(FPG^ GAMMA)*NON_RBC3+K_TR*RBC2-K_TR*RBC3,init= RBC3_0)
      RBC4=ode(deriv= POP_K_GLUCOSE*(FPG^ GAMMA)*NON_RBC4+K_TR*RBC3-K_TR*RBC4,init= RBC4_0)
      VHB=ode(deriv= POP_K_OUT_DILUTION*(1+(POP_E_MAX_DILUTION*CP/(EC_50_DILUTION+CP))-VHB),init= VHB_0)
   }# end ODE

   LIBRARY{
      ##  ADVAN13 TOL=9
      amount=nmadvan(model=13,output=list(A,F))
   }# end LIBRARY
   
   HBA1C = 100*(RBC1+RBC2+RBC3+RBC4)/(NON_RBC1+NON_RBC2+NON_RBC3+NON_RBC4+RBC1+RBC2+RBC3+RBC4)
   HB = (NON_RBC1+NON_RBC2+NON_RBC3+NON_RBC4+RBC1+RBC2+RBC3+RBC4)/VHB
   if (ORIG==1) {
      IPRED = ln(FPG)
   }
   if (ORIG==1) {
      W = RES_FPG
   }
   if (ORIG==1) {
      EPS_1 = eps_RUV_EPS_FPG
   }
   if (ORIG==2) {
      IPRED = ln(HBA1C)
   }
   if (ORIG==2) {
      W = RES_HBA1C
   }
   if (ORIG==2) {
      EPS_1 = eps_RUV_EPS_HBA1C
   }
   if (ORIG==3) {
      IPRED = ln(HB)
   }
   if (ORIG==3) {
      W = RES_HB
   }
   if (ORIG==3) {
      EPS_1 = eps_RUV_EPS_HB
   }
   IRES = DV-IPRED
   IWRES = IRES/W
   }# end MODEL_PREDICTION

} # end of model object

